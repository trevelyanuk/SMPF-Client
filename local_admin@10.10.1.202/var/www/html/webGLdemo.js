	var gl;	var canvas;    	function start()	{		canvas = document.getElementById("c");		gl = initGL(canvas);		if (gl)		{			gl.clearColor(0,0,0, 1);			gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);							gl.enable(gl.DEPTH_TEST);			gl.depthFunc(gl.LEQUAL);						initShaders();			initBuffers();						drawScene();			//setInterval(drawScene, 15);					}			else		{					}	}	function initGL(can)	{		return can.getContext("webgl") || can.getContext("experimental-webgl");		}		function initShaders()	{				var fragmentShader = getShader(gl, "shader-fs");		var vertexShader = getShader(gl, "shader-vs");					//New shaderProgram		shaderProgram = gl.createProgram();				//attach two shaders for Vertex/Fragment		gl.attachShader(shaderProgram, vertexShader);		gl.attachShader(shaderProgram, fragmentShader);				//link those attached shaders		gl.linkProgram(shaderProgram);					if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) 		{			alert("Unable to initialize the shader program.");		}				//use this program (we could have lots of programs)		gl.useProgram(shaderProgram);    		//No idea		 vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");		 gl.enableVertexAttribArray(vertexPositionAttribute);  	}	function getShader(gl, id)	{		var shaderScript;		var theSource;		var currentChild;		var shader;				shaderScript = document.getElementById(id);		if (!shaderScript)		{			return null;		}				theSource = "";		currentChild = shaderScript.firstChild;				while(currentChild) 		{			if (currentChild.nodeType == currentChild.TEXT_NODE) 			{			  theSource += currentChild.textContent;			}						currentChild = currentChild.nextSibling;		}		if (shaderScript.type == "x-shader/x-fragment") 		{			shader = gl.createShader(gl.FRAGMENT_SHADER);		} 		else 			if (shaderScript.type == "x-shader/x-vertex") 			{				shader = gl.createShader(gl.VERTEX_SHADER);			} 			else 			{				// Unknown shader type				return null;			}				gl.shaderSource(shader, theSource);				// Compile the shader program		gl.compileShader(shader);      				// See if it compiled successfully		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 		{  			alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader)); 			return null;  		}    				return shader;	}		function initBuffers() 	{		square = gl.createBuffer();		squarecolours = gl.createBuffer();				gl.bindBuffer(gl.ARRAY_BUFFER, square);	  		var vertices = 	[					1.0,  1.0,  0.0,					-1.0, 1.0,  0.0,					1.0,  -1.0, 0.0,					-1.0, -1.0, 0.0					];	  		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);							}	function drawScene() 	{				var horizAspect = canvas.width/canvas.height;			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);		perspectiveMatrix = makePerspective(45, horizAspect, 0.1, 100.0);		loadIdentity();		mvTranslate([-0.0, 0.0, -3.0]);		gl.bindBuffer(gl.ARRAY_BUFFER, square);		gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);		setMatrixUniforms();		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);	}						function loadIdentity() {  mvMatrix = Matrix.I(4);}function multMatrix(m) {  mvMatrix = mvMatrix.x(m);}function mvTranslate(v) {  multMatrix(Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4());}function setMatrixUniforms() {  var pUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");  gl.uniformMatrix4fv(pUniform, false, new Float32Array(perspectiveMatrix.flatten()));  var mvUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");  gl.uniformMatrix4fv(mvUniform, false, new Float32Array(mvMatrix.flatten()));}